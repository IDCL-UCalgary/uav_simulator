from matrix_utils import hat, vee, deriv_unit_vector, saturate
from integral_utils import IntegralError, IntegralErrorVec3

import datetime
import numpy as np
import pdb


class Control:
    def __init__(self):

        self.t0 = datetime.datetime.now()
        self.t = 0.0
        self.t_pre = 0.0
        self.dt = 1e-9


        # Current state
        self.x = np.zeros(3)
        self.v = np.zeros(3)
        self.a = np.zeros(3)
        self.R = np.identity(3)
        self.W = np.zeros(3)


        # Desired states
        self.xd = np.zeros(3)
        self.xd[0] = 2
        self.xd[2] = -2
        self.xd_dot = np.zeros(3)
        self.xd_2dot = np.zeros(3)
        self.xd_3dot = np.zeros(3)
        self.xd_4dot = np.zeros(3)

        self.Wd = np.zeros(3)
        self.Wd_dot = np.zeros(3)

        self.Rd = np.identity(3)

        self.b1d = np.zeros(3)
        self.b1d[0] = 1.0
        self.b1d_dot = np.zeros(3)
        self.b1d_2dot = np.zeros(3)

        self.b3d = np.zeros(3)
        self.b3d_dot = np.zeros(3)
        self.b3d_2dot = np.zeros(3)

        self.b1c = np.zeros(3)
        self.wc3 = 0.0
        self.wc3_dot = 0.0


        # Flag to enable/disable integral control 
        self.use_integral = False


        self.e1 = np.zeros(3)
        self.e1[0] = 1.0
        self.e2 = np.zeros(3)
        self.e2[1] = 1.0
        self.e3 = np.zeros(3)
        self.e3[2] = 1.0

        self.m = 1.95  # Mass of the rover (kg)
        self.g = 9.81  # Gravitational acceleration (m/s^2)
        self.c_tf = 0.0135  # Torsional moment generated by the propellers
        self.l = 0.23  # Length of the rover arm (m)
        self.J = np.diag([0.02, 0.02, 0.04])  # Inertia matrix of the rover


        # Attitude gains
        self.kR = np.diag([1.6, 1.6, 0.6])  # Attitude gains
        self.kW = np.diag([0.40, 0.40, 0.10])  # Angular rate gains

        self.ky = self.kR[2, 2]  # Yaw gain for decoupled-yaw controller
        self.kwy = self.kR[2, 2]  # Yaw angular rate gain for decoupled-yaw 
            # controller


        # Position gains
        self.kX = np.diag([16.0, 16.0, 16.0])  # Position gains
        self.kV = np.diag([13.0, 13.0, 13.0])  # Velocity gains


        # Integral gains
        self.kIR = 0.015  # Attitude integral gain
        self.ki = 0.01  # Position integral gain
        self.kI = 0.01  # Attitude integral gain for roll and pitch
        self.kyI = 0.02  # Attitude integral gain for yaw
        self.kIX = 4.0  # Position integral gains
        self.c1 = 1.0  # Parameters for decoupled-yaw integral control
        self.c2 = 1.0  # Parameters for decoupled-yaw integral control
        self.c3 = 1.0  # Parameters for decoupled-yaw integral control


        self.fM = np.zeros((4, 1))  # Force-moment vector
        self.f_total = 0.0  # Calculated forces required by each moter

        fM_to_forces = np.array([
            [1.0, 1.0, 1.0, 1.0],
            [0.0, -self.l, 0.0, self.l],
            [self.l, 0.0, -self.l, 0.0],
            [-self.c_tf, self.c_tf, -self.c_tf, self.c_tf]
        ])
        self.fM_to_forces_inv = np.linalg.inv(fM_to_forces)  # Force to 
            # force-moment conversion matrix
        

        # Integral errors
        self.eIX = IntegralErrorVec3()  # Position integral error
        self.eIR = IntegralErrorVec3()  # Attitude integral error
        self.eI1 = IntegralError()  # Attitude integral error for roll axis
        self.eI2 = IntegralError()  # Attitude integral error for pitch axis
        self.eIy = IntegralError()  # Attitude integral error for yaw axis
        self.eIX = IntegralError()  # Position integral error

        self.sat_sigma = 1.8

    
    def run(self, x, v, a, R, W):
        self.x = x
        self.v = v
        self.a = a
        self.R = R
        self.W = W

        self.position_control()
        self.attitude_control()

        return self.fM


    def position_control(self):

        m = self.m
        g = self.g
        e3 = self.e3

        kX = self.kX
        kV = self.kV
        kIX = self.kIX

        R = self.R
        R_T = self.R.T

        x = self.x
        v = self.v
        W = self.W

        b1d = self.b1d
        b1d_dot = self.b1d_dot
        b1d_2dot = self.b1d_2dot
        
        xd = self.xd
        xd_dot = self.xd_dot
        xd_2dot = self.xd_2dot
        xd_3dot = self.xd_3dot
        xd_4dot = self.xd_4dot

        self.update_current_time()
        self.dt = self.t - self.t_pre

        # Translational error functions
        eX = x - xd  # position error - eq (11)
        eV = v - xd_dot  # velocity error - eq (12)

        # position integral terms
        if self.use_integral:
            self.eIX.integrate(self.c1 * eX + eV, self.dt)  # eq (13)
            self.eIX.error = saturate(self.eIX.error, \
                -self.sat_sigma, self.sat_sigma)
        else:
            self.eIX.set_zero()

        # Force 'f' along negative b3-axis - eq (14)
        # This term equals to R.e3
        A = - kX.dot(eX) \
            - kV.dot(eV) \
            - kIX * self.eIX.error \
            - m * g * e3 \
            + m * xd_2dot

        b3 = R.dot(e3)
        b3_dot = R.dot(hat(W)).dot(e3)  # eq (22)
        f_total = -A.dot(b3)

        # Intermediate terms for rotational errors
        ea = g * e3 \
            - f_total / m * b3 \
            - xd_2dot
        A_dot = - kX.dot(eV) \
            - kV.dot(ea) \
            + m * xd_3dot

        fdot = - A_dot.dot(b3) \
            - A.dot(b3_dot)
        eb = - fdot / m * b3 \
            - f_total / m * b3_dot \
            - xd_3dot
        A_2dot = - kX.dot(ea) \
            - kV.dot(eb) \
            + m * xd_4dot

        b3c, b3c_dot, b3c_2dot = deriv_unit_vector(-A, -A_dot, -A_2dot)

        A2 = -hat(b1d).dot(b3c)
        A2_dot = - hat(b1d_dot).dot(b3c) - hat(b1d).dot(b3c_dot)
        A2_2dot = - hat(b1d_2dot).dot(b3c) \
            - 2.0 * hat(b1d_dot).dot(b3c_dot) \
            - hat(b1d).dot(b3c_2dot)

        b2c, b2c_dot, b2c_2dot = deriv_unit_vector(A2, A2_dot, A2_2dot)

        b1c = hat(b2c).dot(b3c)
        b1c_dot = hat(b2c_dot).dot(b3c) + hat(b2c).dot(b3c_dot)
        b1c_2dot = hat(b2c_2dot).dot(b3c) \
            + 2.0 * hat(b2c_dot).dot(b3c_dot) \
            + hat(b2c).dot(b3c_2dot)

        Rd = np.vstack((b1c, b2c, b3c)).T
        Rd_dot = np.vstack((b1c_dot, b2c_dot, b3c_dot)).T
        Rd_2dot = np.vstack((b1c_2dot, b2c_2dot, b3c_2dot)).T

        Rd_T = Rd.T
        Wd = vee(Rd_T.dot(Rd_dot))

        hat_Wd = hat(Wd)
        Wd_dot = vee(Rd_T.dot(Rd_2dot) - hat_Wd.dot(hat_Wd))

        self.f_total = f_total
        self.Rd = Rd
        self.Wd = Wd
        self.Wd_dot = Wd_dot

        # Roll / pitch
        self.b3d = b3c
        self.b3d_dot = b3c_dot
        self.b3d_2dot = b3c_2dot

        # Yaw
        self.b1c = b1c
        self.wc3 = e3.dot(R_T.dot(Rd).dot(Wd))
        self.wc3_dot = e3.dot(R_T.dot(Rd).dot(Wd_dot)) \
            - e3.dot(hat(W).dot(R_T).dot(Rd).dot(Wd))


    def attitude_control(self):
        
        # This uses the controller defined in "Geometric Controls of a Quadrotor
        # with a Decoupled Yaw Control" 
        # URL: https://doi.org/10.23919/ACC.2019.8815189

        R = self.R
        R_T = self.R.T

        Rd = self.Rd
        Rd_T = self.Rd.T

        b3d = self.b3d
        b3d_dot = self.b3d_dot
        b3d_2dot = self.b3d_2dot

        W = self.W
        Wd = self.Wd

        J = self.J
        
        b1 = R.dot(self.e1)
        b2 = R.dot(self.e2)
        b3 = R.dot(self.e3)

        hat_b3 = hat(b3)

        # Roll/pitch angular velocity vector
        W_12 = W[0] * b1 + W[1] * b2
        b3_dot = hat(W_12).dot(b3)  # eq (26)

        hat_b3d = hat(b3d)
        W_12d = hat_b3d.dot(b3d_dot)
        W_12d_dot = hat_b3d.dot(b3d_2dot)

        eb = hat_b3d.dot(b3)  # eq (27)
        ew = W_12 + hat_b3.dot(hat_b3).dot(W_12d)  # eq (28)

        # Yaw
        ey = -b2.dot(self.b1c)
        ewy = W[2] - self.wc3

        # Attitude integral terms
        eI = ew + self.c2 * eb

        self.eI1.integrate(eI.dot(b1), self.dt)  # b1 axis - eq (29)
        self.eI2.integrate(eI.dot(b2), self.dt)  # b2 axis - eq (30)
        self.eIy.integrate(ewy + self.c3 * ey, self.dt)

        # Control moment for the roll/pitch dynamics - eq (31)
        tau = -self.kR[0, 0] * eb \
            - self.kW[0, 0] * ew \
            - J[0, 0] * b3.T.dot(W_12d) * b3_dot \
            - J[0, 0] * hat_b3.dot(hat_b3).dot(W_12d_dot)
        if self.use_integral:
            tau += -self.kI * self.eI1.error * b1 \
                - self.kI * self.eI2.error * b2

        # Control moment around b1 axis - roll - eq (24)
        M1 = b1.T.dot(tau) + J[2, 2] * W[2] * W[1]

        # Control moment around b2 axis - pitch - eq (24)
        M2 = b2.T.dot(tau) - J[2, 2] * W[2] * W[0]

        # Control moment around b3 axis - yaw - eq (52)
        M3 = - self.ky * ey \
            - self.kwy * ewy \
            + self.J[2, 2] * self.wc3_dot
        
        if self.use_integral:
            M3 += - self.kyI * self.eIy.error

        # Gazebo uses ENU frame, but NED frame is used in FDCL.
        M = np.array([M1, -M2, -M3])

        self.fM[0] = self.f_total
        for i in range(3):
            self.fM[i + 1] = M[i]
            
        f_motor = self.fM_to_forces_inv.dot(self.fM)

        # For saving:
        RdtR = Rd_T.dot(R)
        eR = 0.5 * vee(RdtR - RdtR.T)
        self.eIR.error = np.array([self.eI1.error, self.eI2.error, \
            self.eIy.error])
        eW = W - R_T.dot(Rd).dot(Wd)


    def set_integral_errors_to_zero(self):
        self.eIX.set_zero()
        self.eIR.set_zero()
        self.eI1.set_zero()
        self.eI2.set_zero()
        self.eIy.set_zero()
        self.eIX.set_zero()


    def update_current_time(self):
        self.t_pre = self.t

        t_now = datetime.datetime.now()
        self.t = (t_now - self.t0).total_seconds()


    def get_current_time(self):
        t_now = datetime.datetime.now()
        return (t_now - self.t0).total_seconds()
